from ctypes import CDLL
from ctypes import pointer as ptr
from ctypes import POINTER as ptr_factory
from ctypes import c_double, c_int, c_void_p
from os import sep as os_sep
from os.path import dirname as os_path

import numpy as np

import lib.mosek_h as mosek_h
expopt_lib_path = os_sep.join([os_path(__file__), "lib", "expopt.so"])
expopt_h = CDLL(expopt_lib_path)

# allows the sweet shorthand used below while saving us
# both from "from mosek_h import *" and from modifying
# the files generated by ctypesgen
class module_shortener(object):
    def __init__(self, stub, module):
        self.module = module
        self.stub = stub
    def __getattr__(self, attribute):
        return getattr(self.module, self.stub+attribute) 

MSK = module_shortener("MSK", mosek_h)
MSK_expopt = module_shortener("MSK_expopt", expopt_h)

@MSK.streamfunc
def printcb(void, msg):
    '''All console output from MOSEK should go through this'''
    # comment the below line out to disable console output
    #print msg[:-1]
    return 0

def c_array(py_array, c_type):
    if not isinstance(py_array, list):
        pya = py_array.tolist()
    else:
        pya = py_array
    return (c_type * len(pya))(*pya)

def imize(c, A, map_):
    r = MSK._RES_OK

    numcon = 1+map_[-1]
    numvar, numter   = map(int, A.shape)

    xx = c_array([0]*numvar, c_double)
    y = c_array([0]*numter, c_double)

    numcon, numvar, numter = map(c_int, [numcon, numvar, numter])

    c = c_array(c, c_double)
    subi = c_array(map_, c_int)

    subk = c_array(A.col, c_int)
    subj = c_array(A.row, c_int)
    akj = c_array(A.data, c_double)
    numanz = c_int(len(A.col))
    
    objval = c_double()
    env = MSK.env_t()
    prosta = MSK.prostae()
    solsta = MSK.solstae()
    expopttask = MSK.task_t()
    expopthnd = c_void_p()
    # a little extra work to declare a pointer for expopthnd...
    ptr_expopthnd = ptr_factory(c_void_p)(expopthnd)

    if r == MSK._RES_OK:
        r = MSK._makeenv(ptr(env),  None) 
            
    if r == MSK._RES_OK:
        r = MSK._makeemptytask(env, ptr(expopttask))

    if r == MSK._RES_OK:
        r = MSK._linkfunctotaskstream(expopttask, MSK._STREAM_LOG,  None, printcb)

    if r == MSK._RES_OK:
        # Initialize expopttask with problem data     
        r =  MSK_expopt.setup(expopttask, 
                             c_int(1),  # Solve the dual formulation       
                             numcon, 
                             numvar, 
                             numter, 
                             subi, 
                             c, 
                             subk, 
                             subj, 
                             akj, 
                             numanz, 
                             ptr_expopthnd
                             # Pointer to data structure holding nonlinear data 
                             )

    # Any parameter can now be changed with standard mosek function calls  
    if r == MSK._RES_OK:
        r = MSK._putintparam(expopttask, MSK._IPAR_INTPNT_MAX_ITERATIONS, c_int(200)) 

    # Optimize,  xx holds the primal optimal solution, 
    # y holds solution to the dual problem if the dual formulation is used

    if r == MSK._RES_OK:
        r = MSK_expopt.imize(expopttask, 
                            ptr(prosta), 
                            ptr(solsta), 
                            ptr(objval), 
                            ptr(xx), 
                            ptr(y), 
                            ptr_expopthnd)
        
    # Free data allocated by expoptsetup 
    if ptr_expopthnd:
        MSK_expopt.free(expopttask, 
                       ptr_expopthnd)

    MSK._deletetask(ptr(expopttask))
    MSK._deleteenv(ptr(env))

    return [np.exp(x) for x in xx]
